# -*- coding: utf-8 -*-

import os, sys
import json, re, glob
from ipaddress import ip_address, IPv6Address
from logging import getLogger
from priv_module_helpers.splunk_helpers import splunk_searcher as _splunk

from validator_base import ValidatorBase
from . import TYPECODE_MALWARE, BLACK, WHITE, GRAY

dirpath = os.path.dirname( os.path.abspath(__file__) )+"/"
apppath = dirpath+"../../"

_IOC_SPLUNK = "splunk-license01.dhsoc.jp"

_ALMOST_FP_VIRUS = [
#	"APC",
	"InstallCore",
	"Bundled",
	"ProduKey",
	"AutoKMS",
	"EICAR",
	"CoinMiner",
	"CoinLoader"
]

_ALMOST_FP_SUBCATEGORY = [
	"HackTool"
]

_LOW_RISK_VIRUS = [
	"Slimware",
	"Ask",
	"MyWebSearch",
	"Asparnet",
	"OpenCandy",
	"WebCompanion",
	"IObit",
	"Systweak",
	"SoftonicDownloader",
	"CnsMin"
]

def get_logger(log_name="MalwareValidator"):
	return getLogger(log_name)

class MalwareValidator(ValidatorBase):
	search_index = "dhsoc_hash_info"
	search_source = "analyst_feedback"
	search_earliest = "-10y@y"
	search_latest   = "now"

	cyfirma_index = "cyfirma_ioc"
	cyfirma_source = "cyfirma"
	cached_hashes = { "all" : {} }
	get_all_hashes = False
	splunk = _splunk.MySearcher

	@classmethod
	def initialize_module(cls, is_fource=False):
		logger = get_logger()
		logger.info("initialize malware validator")
		if cls.get_all_hashes:
			if not is_fource:
				return
		cls._init_splunk()
		cls._cache_appinfo_wDHSOC()
		cls.get_all_hashes = True

	@classmethod
	def is_target(cls, alert):
		if "versions" in alert:
			_type = alert["alert_summary"]["alert_type"].lower()
			return _type in ( "malware", "pup" )
		return False

	def __init__(self, alert, validator_config, intel, cyfirma, product, customer, vtapi, rm_helper=None):
		super(MalwareValidator, self).__init__(alert, 
				TYPECODE_MALWARE, get_logger(),
				product=product,  customer=customer,
				cyfirma=cyfirma,  validator_config=validator_config,
				intel=intel,      vtapi=vtapi, rm_helper=rm_helper)
		self.results["malware"] = {}
		self._init_splunk()
		if not self.get_all_hashes:
			self._cache_appinfo_wDHSOC()

	@classmethod
	def _init_splunk(cls):
		if not cls.splunk.is_init():
			if "." in _IOC_SPLUNK:
				cfg_name = _IOC_SPLUNK.split(".")[0]
			else:
				cfg_name = _IOC_SPLUNK
			cls.splunk.init_splunk_by_cfg_file(cfg_name, app="dhsoc_ioc")

	def validate_falsepositive(self):
		self.logger.info( "start to FP check at malware alert." )
		msg = ""
		customer_name = self.alert["alert_src"]["customer_name"]
		results = []
		hashes = list(set([ each["sha256Hash"]
			for each in self.alert["alert_summary"]["malware_info"] ]))
		for each in hashes:
			if each is None:
				severity, ticket_id, msg = "低" , None , "Hash value is none."
			else:
				severity, ticket_id, msg = self.check_each_malware(customer_name, each)
				#if severity in [ "中", "高", None ]:
				if severity is None:
					if self._check_fp_by_malware_type(each):
						severity = u"未"
				if severity == "cyfirma":
					severity = None
			self.logger.debug("{} : {} : {}".format(severity, ticket_id, msg))
			results.append({"severity"  : severity,
							"message"   : msg,
							"hash"      : each,
							"ticket_id" : ticket_id })
		severity = self._get_high_severity(results)
		if severity is None:
			self.is_positive = True
			self.is_emerg = True
		else:
			self.correct_severity = severity
			if severity == "-":
				self.is_positive = False
			elif severity == "未":
				self.is_positive = True
				self.is_gray = True
			else:
				self.is_positive = True
				self.is_emerg = True
		self.results["malware"]["result"] = results
		self.logger.info("highest severity:{} at ID:{}".format(
			severity, self.alert["alert_summary"]["alert_id"] ))

	def get_type_by_str(self):
		return "malware"

	def _check_severity_by_malware_type(self, sha256Hash):
		for each in self.alert["alert_summary"]["malware_info"]:
			if each["sha256Hash"] == sha256Hash:
				if each["virusName"] in _LOW_RISK_VIRUS:
					self.logger.debug("this malware is {}. it is low risk malware.".format(each["virusName"]))
					return True
		return False

	def _check_fp_by_malware_type(self, sha256Hash):
		malinfo = self._get_malware_info(sha256Hash)
		if malinfo:
			#if malinfo["reputationProperty"] == "SUSPECT_MALWARE":
			#	self.logger.debug("this malware is SUSPECT_MALWARE. it is almost false positive.")
			#	return True
			if malinfo["virusName"] in _ALMOST_FP_VIRUS:
				self.logger.debug("this malware is {}. it is almost false positive.".format(malinfo["virusName"]))
				return True
			elif malinfo["virusSubCategory"] in _ALMOST_FP_SUBCATEGORY:
				self.logger.debug("this malware category is {}. it is almost false positive or low Risk.".format(malinfo["virusSubCategory"]))
				return True
		return False

	def _get_high_severity(self, results):
		def get_score(curr_severity):
			if curr_severity == "-":
				return 1
			elif curr_severity == "低":
				return 2
			elif curr_severity == "未":
				return 3
			elif curr_severity is None:
				return 4
			elif curr_severity == "中":
				return 5
			elif curr_severity == "高":
				return 6
			else:
				return 0

		severity = None
		score = 0
		self.logger.debug("alert num is {}".format(len(results)))
		for each in results:
			curr_severity = each["severity"]
			curr_score = get_score(curr_severity)
			self.logger.debug("Severity:{} Score:{}".format(
				curr_severity, curr_score))
			if score < curr_score:
				score = curr_score
				severity = curr_severity
		return severity

	def check_each_malware(self, customer_name, sha256):
		self.logger.debug("check by DHSOC Hash IOC.")
		res = self._search_splunk_wDHSOC(customer_name, sha256)
		if len(res) is not 0:
			info = res[0]
			self.logger.info("{} is detected by DHSOC IOC(Hash).".format(sha256))
			if "analyst_comment" in info:
				return info["severity"], info["ticket_id"], info["analyst_comment"]
			else:
				return info["severity"], info["ticket_id"], ""

		self.logger.debug("check by DHSOC Condition Based IOC.")
		res = self._search_splunk_wCyfirma(sha256)
		if len(res) is not 0:
			res = res[0]
			self.logger.debug("detected by cyfirma:{}".format(res.get("id")))
			msg = "detected by cyfirma IOC. fileName:{}".format(
					res.get("file_name"))
			return "cyfirma", "cyfirmaID:{}".format(res.get("id")), msg

		self.logger.debug("unknown by cyfirma IOC.")
		try:
			ticket_id, severity, msg = self._getinfo_by_malware_hash_at_past_ticket_in_redmine(sha256)
			if ticket_id:
<<<<<<< HEAD
				if severity == "-" or severity == "低":
					severity = "未" #TODO アナリストチェック可能な状態にするため(一時的な措置)
=======
				# if severity == "-" or severity == "低": # Not changing the severity
				# 	severity = "未" #TODO アナリストチェック可能な状態にするため(一時的な措置)
>>>>>>> develop
				return severity, ticket_id, msg
		except Exception as e:
			self.logger.info("error occurred at DHSOC RedMine Ticket Search.")
			self.logger.exception(e)
		self.logger.debug("unknown by redmine tickets in 7 days.")
		try:
			res = self._search_splunk_wDHSOC_Condition(customer_name, sha256)
			if len(res) is not 0:
				info = res[0]
				self.logger.info("{} is detected by DHSOC IOC(Condition).".format(sha256))
				rep = info["reputation"]
				if rep == "high":
					sev = u"高"
				elif rep == "medium":
					sev = u"中"
				elif rep == "low":
					sev = u"低"
				elif rep == "gray":
					sev = u"未"
				elif rep == "white":
					sev = u"-"
				else:
					sev = None
				return sev, info["id"], info["message"]
		except Exception as e:
			self.logger.info("error occurred at DHSOC Condition based IOC.")
			self.logger.exception(e)
		self.logger.debug("unknown by dhsoc IOC.")
		if self._check_severity_by_malware_type(sha256):
			severity = u"低"
			msg = "this is low risk(PUP/Adware etc) malware."
			return severity, None, msg
		elif self._is_pup(sha256):
			self.logger.debug("this hash is PUP.")
			severity = "低"
			msg =  "unknown PUP without virustotal."
			return severity, None, msg
		else:
			exist, severity, msg = self._check_by_virustotal(sha256)
			if exist:
				return severity, None, "virustotal check:({})".format(msg)
			else:
				self.logger.debug("unknown by virustotal.")
				return severity, None, "unknown all"

	def _getinfo_by_malware_hash_at_past_ticket_in_redmine(self, ps_hash):
		info = self.rm_helper.get_info_by_hash_from_past_ticket(
				ps_hash, customer=self.alert["alert_src"]["customer_name"])
		if info:
			return info["ticket_id"], info["severity"], info["message"]
		else:
			return None, None, None

	def _check_by_virustotal(self, ps_hash):
		def detect_detail_to_str(detected_detail):
			msg = []
			for each in detected_detail:
				msg.append(
						"{}:{}".format(each["vendor"], each["result"])
				)
			return "\n".join(msg)

		result = self.vtapi.search_hashes( [ps_hash] )
		res = result[0]
		if not res["exist"]:
			return None, None, None
		vendor_num = len(res["detected_vendors"])
		msg = detect_detail_to_str(res["detected_detail"])
		msg = "VirusTotal({})\n{}".format(res["result"], msg)
		rep = self.vtapi.check_reputation("hash", res)
		self.logger.debug("VirusTotal check result:{}".format(rep["reputation"]))
		if rep["reputation"] in ("benign", "suspicious"):
			return True, u"未", msg 
		else:
			return True, None, msg 

# private
	def _get_query4cyfirma(self, file_hash):
		q  = 'search index="{}" source="{}" earliest="{}" latest="{}" {}'.format(
				self.cyfirma_index,    self.cyfirma_source,
				self.search_earliest, self.search_latest,
				file_hash )
		q += '| rename observable.object.properties.fileName.value as file_name'
		q += '| table _time,id,file_name,_raw'
		q += '| dedup file_name sortby -_time'
		q += '| head 1'
		return q

	@classmethod
	def _get_query4dhsoc(cls, customer_name=None, file_hash=None):
		q  = 'search index="{}" source="{}" earliest="{}" latest="{}" '.format(
				cls.search_index,    cls.search_source,
				cls.search_earliest, cls.search_latest )
		cond = ""
		if file_hash:
			cond = ' hash="{}" '.format(file_hash)
		if customer_name:
			if not cond == "":
				cond += " AND "
			q += ' ( customer_name="all" OR customer_name="{}" ) '.format(
					customer_name)
		q += cond
		q += '| spath customer_name | spath hash | spath analyst{}.note'
		q += '| where isnotnull(customer_name) AND  isnotnull(hash) '
		q += '| rename analyst{}.note as analyst_comment'
		q += '| table _time,customer_name,analyst_comment,hash,ticket_id,severity'
		q += '| dedup hash sortby -_time'
		return q

	def _search_splunk_wDHSOC_Condition(self, customer_name, sha256):
		def _get_and_check_fields(each):
			_id  = each.get("id")
			_rep = each.get("reputation")
			_msg = each.get("message")
			condition = each.get("detail")
			if not (isinstance(condition,  dict) and
					isinstance(_id,  basestring) and
					isinstance(_rep, basestring) and
					isinstance(_msg, basestring) ):
				return False, None, None, None, None, None
			op = condition.get("match_type")
			values = condition.get("values")
			except_severity = condition.get("except_severity")
			if not(isinstance(op, basestring) and isinstance(values, list)):
				return False, None, None, None, None, None
			elif except_severity is not None:
				sev = self.alert["alert_summary"]["severity"]
				op = op.lower()
				if sev == u"高":
					sev = "high"
				elif sev == u"中":
					sev = "medium"
				elif sev == u"低":
					sev = "low"
				flag = not(sev in except_severity) and op in ("or", "and")
			else:
				flag = False
			return flag, op, values, _id, _rep, _msg

		def _is_match(value, target, vtype):
			vtype = vtype.lower()
			if vtype == "exact":
				return value == target
			elif vtype == "ciexact":
				return value.lower() == target.lower()
			elif vtype == "include":
				return value in target
			elif vtype == "regexp":
				return re.search(value, target) is not None
			elif vtype == "neq":
				return not(value == target)
			elif vtype == "exclude":
				return not(value in target)

		def _get_need_info_in_record(record):
			field = record.get("field")
			value = record.get("value")
			vtype = record.get("type" )
			return field, value, vtype

		malinfo = self._get_malware_info(sha256)
		result = []
		if malinfo:
			match_flag = False
			infos = self._search_mydb("malware", customer_name)
			self.logger.debug("checked condition Num:{}".format(len(infos)))
			for each in infos:
				flag, op, values, _id, _rep, _msg = _get_and_check_fields(each)
				self.logger.debug("ID:{} is Valid:{}".format(_id, flag))
				if flag:
					for v in values:
						field, value, vtype = _get_need_info_in_record(v)
						if( field in malinfo              and
							isinstance(value, basestring) and
							isinstance(vtype, basestring) ):
							target = malinfo[field]
							if target and _is_match(value, target, vtype):
								match_flag = True
								if op == "or":
									break
							else:
								if op == "and":
									match_flag = False
									break
					if match_flag:
						self.logger.debug("DHSOC Condition based IOC -> ID:{} is Matched.".format(_id, flag))
						each_res = { "id"    : _id,
								"reputation" : _rep,
								"hash"       : sha256,
								"message"    : _msg }
						result.append(each_res)
						break
		return result

	def _search_mydb(self, info, customer_name=None, rec_type="malware"):
		if customer_name is None:
			customer_name = self.alert["alert_src"]["customer_name"]
		for i in range(0, 3):
			try:
				return self.intel.search(info, self.product, customer_name, rec_type, max_count=1000)
			except OSError as e:
				self.logger.warning("error occurred at search_mydb({})".format(e.message))
			except IOError as e:
				self.logger.warning("error occurred at search_mydb({})".format(e.message))
		return []

	def _get_malware_info(self, sha256Hash):
		for each in self.alert["alert_summary"]["malware_info"]:
			if each["sha256Hash"] == sha256Hash:
				return each
		return None

	def _search_splunk_wDHSOC(self, customer_name, sha256):
		if customer_name:
			customer_name = customer_name.lower()
		if self.get_all_hashes:
			result = []
			if customer_name in self.cached_hashes:
				if sha256 in self.cached_hashes[customer_name]:
					result.append(self.cached_hashes[customer_name][sha256])
			if len(result) is 0:
				if sha256 in self.cached_hashes["all"]:
					result.append(self.cached_hashes["all"][sha256])
		else:
			queries = self._get_query4dhsoc(customer_name, sha256)
			result = self.splunk.raw_search(queries)
		return result

	@classmethod
	def _get_all_wDHSOC(cls):
		logger = get_logger()
		queries = cls._get_query4dhsoc()
		result = cls.splunk.raw_search(queries, max_count=0)
		logger.info("Total dhsoc_hash_info Num:{}".format(len(result)))
		return result

	@classmethod
	def _cache_appinfo_wDHSOC(cls):
		logger = get_logger()
		logger.info("cached dhsoc_hash_info.")
		raw_results = [ dict(each) for each in cls._get_all_wDHSOC() ]
		results = { "all" : {} }
		for each in raw_results:
			if not "customer_name" in each or not "hash" in each:
				continue
			customer_name = each["customer_name"].lower()
			if not customer_name in results:
				results[customer_name] = {}
			results[customer_name][each["hash"]] = each
		MalwareValidator.cached_hashes = results
		MalwareValidator.get_all_hashes = True

	def _search_splunk_wCyfirma(self, sha256):
		result = self.cyfirma.check_hashes( [ sha256 ] )
		#queries = self._get_query4cyfirma(sha256)
		#result = self.splunk.raw_search(queries)
		if len(result) > 1:
			return [ result[0] ]
		else:
			return result

	def _is_pup(self, sha256Hash):
		if self.alert["alert_summary"]["alert_type"].lower() == "pup":
			self.logger.debug("PUP alert.")
			severity = "低"
			msg =  "unknown PUP without virustotal."
			return severity, None, msg

		for info in self.alert["alert_summary"]["malware_info"]:
			if info["sha256Hash"] == sha256Hash:
				return (info["reputationProperty"] == "PUP" or
						info["virusCategory"]      == "PUP" or
						info["virusSubCategory"]   == "PUP" or
						info["virusSubCategory"]   == "Adware" )
		return False

