# -*- coding: utf-8 -*-

import os, sys
import json, re, glob
from ipaddress import ip_address, IPv6Address
from logging import getLogger
from priv_module_helpers.splunk_helpers import splunk_searcher as _splunk

dirpath = os.path.dirname( os.path.abspath(__file__) )+"/"
apppath = dirpath+"../../"

_IOC_SPLUNK = "splunk-license01.dhsoc.jp"

TYPECODE_MALWARE = 3

BLACK = 0xf
WHITE = 0x0
GRAY  = 0x8
WGRAY = 0x1
BGRAY = 0xe

def get_logger(log_name="MalwareValidator"):
	return getLogger(log_name)

class MalwareValidator(object):
	search_index = "dhsoc_hash_info"
	search_source = "analyst_feedback"
	search_earliest = "-10y@y"
	search_latest   = "now"

	cyfirma_index = "cyfirma_ioc"
	cyfirma_source = "cyfirma"
	get_all_hashes = False

	@classmethod
	def is_target(cls, alert):
		if "versions" in alert:
			categories = alert["alert_summary"]["category"]
			if "NGAV" in categories:
				return True
			elif "Known Malware" in categories:
				return True
			elif "Machine Learning" in categories:
				return True
		return False

	def __init__(self, alert, product, intel=None, vtapi=None, cyfirma=None, rm_helper=None):
		self.logger = get_logger()
		self.alert = alert
		self.product = product
		self.is_positive = None
		self.message = []
		self.alert_type = TYPECODE_MALWARE
		self.chached_hashes = None
		self.get_all_hashes = False
		if "versions" in alert:
			self.version = alert["versions"]
		else:
			self.version = None
		self.splunk = _splunk.MySearcher
		if not self.splunk.is_init():
			if "." in _IOC_SPLUNK:
				cfg_name = _IOC_SPLUNK.split(".")[0]
			else:
				cfg_name = _IOC_SPLUNK
			self.splunk.init_splunk_by_cfg_file(cfg_name, app="dhsoc_ioc")
		self.vtapi = vtapi # viruttotal function
		self.intel = intel # MyDBSearcher function
		self.cyfirma = cyfirma #IOC Search function
		self.rm_helper = rm_helper
		self._cache_appinfo_wDHSOC()
		if not self.get_all_hashes:
			self._cache_appinfo_wDHSOC()

	def validate_falsepositive(self):
		self.logger.info( "start to FP check at malware alert." )
		msg = ""
		customer_name = self.alert["alert_src"]["customer_name"]
		results = []
		malwares = self._get_malware_list()
		for each in malwares:
			eachhash = each["ps_hash"]
			severity, ticket_id, msg = self._check_each_malware(customer_name, eachhash)
			if severity == "cyfirma":
				severity = None
			self.logger.debug("{} : {} : {}".format(severity, ticket_id, msg))
			results.append({"severity"  : severity,
							"message"   : msg,
							"hash"      : eachhash,
							"ticket_id" : ticket_id })
		severity = self._get_high_severity(results)
		self.logger.info("highest severity:{} at ID:{}".format(
			severity, self.alert["alert_summary"]["alert_id"] ))
		self.results = results
		return severity, self.get_message()

	def get_message(self):
		message = []
		message.append("sha256,severity,referenced")
		for each in self.results:
			message.append("{}:{}:{}. Detail is Followings.\n{}\n".format(
				each["hash"], each["severity"], each["ticket_id"],
				each["message"]))
		return message

	# private

	def _get_malware_list(self):
		results = []
		for each in self.alert["alert_detail"]["event_detail"]:
			each_malware = None
			if each["category"] == "NGAV":
				results.append( self._to_malware_info(each) )
		return results
	
	def _to_malware_info(self, ev_info):
		psname = ev_info["ps_name"]
		pspid  = ev_info["ps_pid"]
		info = {
				"ps_name" : psname,
				"ps_pid"  : pspid,
				"ps_hash" : "",
				"ps_path" : "",
				"cmdline" : "",
				"is_stop" : False,
				"alert_name"    : ev_info["alert_name"],
				"is_quarantine" : False }
		for each in self.alert["alert_detail"]["process_detail"]:
			if each["ps_name"] == psname and each["ps_pid"] == pspid:
				info["ps_hash"] = each["ps_hash"]
				info["ps_path"] = each["ps_path"]
				info["cmdline"] = each["ps_cmdline"]
				if each.get("ps_ended"):
					info["is_stop"] = True
		api_info = self.alert["alert_detail"].get("api_info")
		if api_info:
			q_files = api_info.get("quarantined_files")
			if q_files:
				for each in q_files:
					if each.get("sha256") == info["ps_hash"]:
						if each.get("state") == "quarantined":
							info["is_quarantine"] = True
		return info

#	def _check_fp_by_malware_type(self, sha256Hash):
#		malinfo = self._get_malware_info(sha256Hash)
#		if malinfo:
#			#if malinfo["reputationProperty"] == "SUSPECT_MALWARE":
#			#	self.logger.debug("this malware is SUSPECT_MALWARE. it is almost false positive.")
#			#	return True
#			if malinfo["virusName"] in _ALMOST_FP_VIRUS:
#				self.logger.debug("this malware is {}. it is almost false positive.".format(malinfo["virusName"]))
#				return True
#			elif malinfo["virusSubCategory"] in _ALMOST_FP_SUBCATEGORY:
#				self.logger.debug("this malware category is {}. it is almost false positive or low Risk.".format(malinfo["virusSubCategory"]))
#				return True
#		return False

	def _get_high_severity(self, results):
		def get_score(curr_severity):
			if curr_severity == "-":
				return 1
			elif curr_severity == "未":
				return 2
			elif curr_severity == "低":
				return 3
			elif curr_severity is None:
				return 4
			elif curr_severity == "中":
				return 5
			elif curr_severity == "高":
				return 6
			else:
				return 0

		severity = None
		score = 0
		self.logger.debug("alert num is {}".format(len(results)))
		for each in results:
			curr_severity = each["severity"]
			if curr_severity:
				curr_score = get_score(curr_severity)
				self.logger.debug("Severity:{} Score:{}".format(
					curr_severity, curr_score))
				if score < curr_score:
					score = curr_score
					severity = curr_severity
		return severity

	def _check_each_malware(self, customer_name, sha256):
		self.logger.debug("check by DHSOC Hash IOC.")
		res = self._search_splunk_wDHSOC(customer_name, sha256)
		if len(res) is not 0:
			info = res[0]
			self.logger.info("{} is detected by DHSOC IOC(Hash).".format(sha256))
			if "analyst_comment" in info:
				return info["severity"], info["ticket_id"], info["analyst_comment"]
			else:
				return info["severity"], info["ticket_id"], ""

		self.logger.debug("check by DHSOC Condition Based IOC.")
		res = self._search_splunk_wCyfirma(sha256)
		if len(res) is not 0:
			res = res[0]
			self.logger.debug("detected by cyfirma:{}".format(res["id"]))
			msg = "detected by cyfirma IOC. fileName:{}".format(
					res["file_name"])
			return "cyfirma", "cyfirma:{}".format(res["id"]), msg

		self.logger.debug("unknown by cyfirma IOC.")
		try:
			ticket_id, severity, msg = self._getinfo_by_malware_hash_at_past_ticket_in_redmine(sha256)
			if ticket_id:
				# if severity == "-" or severity == "低": # Not changing the severity
				# 	severity = "未" #TODO アナリストチェック可能な状態にするため(一時的な措置)
				return severity, ticket_id, msg
		except Exception as e:
			self.logger.info("error occurred at DHSOC RedMine Ticket Search.")
			self.logger.exception(e)
		self.logger.debug("unknown by redmine tickets in 7 days.")

		try:
			res = self._search_splunk_wDHSOC_Condition(customer_name, sha256)
			if len(res) is not 0:
				info = res[0]
				self.logger.info("{} is detected by DHSOC IOC(Condition).".format(sha256))
				rep = info["reputation"]
				if rep == "high":
					sev = u"高"
				elif rep == "medium":
					sev = u"中"
				elif rep == "low":
					sev = u"低"
				elif rep == "gray":
					sev = u"未"
				elif rep == "white":
					sev = u"-"
				else:
					sev = None
				return sev, info["id"], info["message"]
		except Exception as e:
			self.logger.info("error occurred at DHSOC Condition based IOC.")
			self.logger.exception(e)
		self.logger.debug("unknown by dhsoc IOC.")
		if self._is_low_confidence():
			self.logger.debug("unknown by virustotal and low confidence.")
			return "-", None, "unknown low confidence malware"
		elif self.alert["alert_summary"].get("alert_type") == "pup":
			self.logger.debug("PUP/Adware detected.")
			return "低", None, "unknown pup/adware."

		exist, severity, msg = self._check_by_virustotal(sha256)
		if exist:
			return severity, None, "virustotal check:({})".format(msg)
		else:
			self.logger.debug("unknown by virustotal.")
			return severity, None, "unknown all"

	def _getinfo_by_malware_hash_at_past_ticket_in_redmine(self, ps_hash):
		info = self.rm_helper.get_info_by_hash_from_past_ticket(
				ps_hash, customer=self.alert["alert_src"]["customer_name"])
		if info:
			return info["ticket_id"], info["severity"], info["message"]
		else:
			return None, None, None

	def _is_low_confidence(self):
		confidence = self.alert["alert_summary"].get("alert_subtype")
		return confidence == "low"

	def _is_medium_confidence(self, sha256): #TODO
		pt = "(?i)machine\\s+learning-based\\s+AV\\s+protection.*medium\\s+confidence\\s+threshold"
		ppid = None
		malware_info = self.alert["alert_detail"].get("malware_info")
		event_detail = self.alert["alert_detail"].get("event_detail")
		if malware_info and event_detail:
			for each in malware_info:
				if each["ps_hash"] == sha256:
					ppid = each["ps_pid"]
			for each in event_detail:
				if( each["ps_pid"] == ppid and
					isinstance(each["description"], basestring)):
					return re.search(pt, each["description"]) is not None
		else:
			return False

	def _check_by_virustotal(self, ps_hash):
		def detect_detail_to_str(detected_detail):
			msg = []
			for each in detected_detail:
				msg.append(
						"{}:{}".format(each["vendor"], each["result"])
				)
			return "\n".join(msg)

		result = self.vtapi.search_hashes( [ps_hash] )
		res = result[0]
		if not res["exist"]:
			return None, None, None
		vendor_num = len(res["detected_vendors"])
		msg = detect_detail_to_str(res["detected_detail"])
		msg = "VirusTotal({})\n{}".format(res["result"], msg)
		rep = self.vtapi.check_reputation("hash", res)
		self.logger.debug("VirusTotal check result:{}".format(rep["reputation"]))
		if rep["reputation"] in ("benign", "suspicious"):
			return True, u"未", msg 
		else:
			return True, None, msg 

	def _get_query4cyfirma(self, file_hash):
		q  = 'search index="{}" source="{}" earliest="{}" latest="{}" {}'.format(
				self.cyfirma_index,    self.cyfirma_source,
				self.search_earliest, self.search_latest,
				file_hash )
		q += '| rename observable.object.properties.fileName.value as file_name'
		q += '| table _time,id,file_name,_raw'
		q += '| dedup file_name sortby -_time'
		q += '| head 1'
		return q

	def _get_query4dhsoc(self, customer_name=None, file_hash=None):
		q  = 'search index="{}" source="{}" earliest="{}" latest="{}" '.format(
				self.search_index,    self.search_source,
				self.search_earliest, self.search_latest )
		if customer_name and file_hash:
			q += ' hash="{}" AND ( customer_name="all" OR customer_name="{}" ) '.format(file_hash, customer_name)
		q += '| spath customer_name | spath hash | spath analyst{}.note'
		q += '| where isnotnull(customer_name) AND  isnotnull(hash) '
		q += '| rename analyst{}.note as analyst_comment'
		q += '| table _time,customer_name,analyst_comment,hash,ticket_id,severity'
		q += '| dedup hash sortby -_time'
		return q

	def _search_splunk_wDHSOC_Condition(self, customer_name, sha256):
		malinfo = self._get_malware_info(sha256)
		result = []
		if malinfo:
			match_flag = False
			records = self._search_mydb("malware", customer_name)
			self.logger.debug("checked condition Num:{}".format(len(records)))
			ps_name = malinfo.get("ps_name")
			ps_pid  = malinfo.get("ps_pid")

			for rec in records:
				rec_id = rec.get("id")
				rec_rev = rec.get("rev")
				reputation = rec.get("reputation")
				message    = rec.get("message")
				detail = rec.get("detail")
				try:
					is_match = self.fp_check_malware_by_each_record(
						ps_name, ps_pid,  sha256,     rec,
						rec_id,  rec_rev, reputation, message, detail)
					if is_match:
						self.logger.info("alert is matched ID:[{}] Rev:[{}]".format(
							rec.get("id"), rec.get("rev")))
						break
				except Exception as e:
					self.logger.error("unknown error at checking record ID:{}".format(rec_id))
			if is_match:
				self.logger.debug("DHSOC Condition based IOC -> ID:{} is Matched.".format(rec_id, reputation))
			else:
				self.logger.debug("un-match any conditions.")
				reputation = None
				message = "unmatched any conditions"
				rec_id = None

			if reputation and rec_id:
				each_res = { "id"    : rec_id,
						"reputation" : reputation,
						"hash"       : sha256,
						"message"    : message }
				result.append(each_res)
		return result

	def fp_check_malware_by_each_record(self, ps_name, ps_pid, sha256,
				rec, rec_id, rec_rev, reputation, message, detail):
		is_match = None
		if not( isinstance(rec_id,  basestring) and
				isinstance(rec_rev, basestring) ):
			self.logger.warning(
					"this record is corrupt. ID:{}".format(rec_id))
			return None
		elif not reputation in ("black", "white", "gray", "high", "low", "medium"):
			self.logger.warning(
					"has no correct reputation info [{}]".format(rec))
			return None
		elif not(isinstance(detail, dict) and detail.get("expected")):
			self.logger.warning("record is corrupted. [{}]".format(rec))
			return None
		allconditions = detail["expected"]
		if not(isinstance(allconditions, list)):
			self.logger.warning("record is corrupted. [{}]".format(rec))
			return None
		is_match = True
		for cnd_group in allconditions:
			target, conditions = self._get_match_target(
					cnd_group, ps_name, ps_pid)
			if not(target and conditions):
				self.logger.info(
						"data or conditions are null(or blank).")
				is_match = False
			elif not self._is_match_allcondition(target, conditions):
				self.logger.debug(
						"unmatch condition.")
				is_match = False
		return is_match

	def _get_match_target(self, cnd_group, ps_name, ps_pid):
		if isinstance(cnd_group, dict):
			position = cnd_group.get("data_position")
			conditions = cnd_group.get("conditions")
			if isinstance(position, basestring):
				if position == "event_detail":
					self.logger.debug("data position is event_detail")
					data = self.alert["alert_detail"]["event_detail"]
					data = [] if data is None else data
					for each in data:
						if ps_pid == each.get("ps_pid"):
							return each, conditions
				elif position == "process_detail":
					self.logger.debug("data position is process_detail")
					data = self.alert["alert_detail"]["process_detail"]
					data = [] if data is None else data
					for each in data:
						if ps_pid == each.get("ps_pid"):
							return each, conditions
				elif position == "malware_info":
					self.logger.debug("data position is malware_info")
					data = self.alert["alert_detail"]["malware_info"]
					data = [] if data is None else data
					for each in data:
						if ps_pid == each.get("ps_pid"):
							return each, conditions
		return None, None

	def _is_match_allcondition(self, target, conditions):
		def is_match(data, cond):
			field = cond["field"]
			value = cond["value"]
			dtype = cond["type"]
			op    = cond["op"]
			section = cond["section"]
			if isinstance(section, basestring):
				data = data.get(section)
			if data and field in data:
				target_value = str(data[field])
				if dtype == "regex":
					result = re.search(value, target_value) is not None
				elif dtype == "regexp":
					result = re.search(value, target_value) is not None
				elif dtype == "ciexact":
					result = (value.lower() == target_value.lower())
				elif dtype == "exact":
					result = (value == target_value)
				elif dtype == "exact":
					result = (value == target_value)
				elif dtype == "include":
					result = (value in target_value)
				elif dtype == "ciinclude":
					result = (value.lower() in target_value.lower())
				elif dtype.startswith("length"):
					if dtype.endswith("gt"):
						result = (value > len(target_value))
					elif dtype.endswith("lt"):
						result = (value < len(target_value))
					else:
						result = (value == len(target_value))
				else:
					result = None
				if result is None:
					return False
				elif op == "not":
					return not result
				else:
					return result
			return False
		def is_except_condition(each):
			return( "section" in each and
					each.get("op") in (None, "not") and
					isinstance(each.get("field"), basestring) and
					isinstance(each.get("type"),  basestring) and
					isinstance(each.get("value"), basestring) )

		if not(isinstance(conditions, list) and len(conditions) > 0):
			return False
		match_flag = True
		for each in conditions:
			if not is_except_condition(each):
				self.logger.info("this is corrupt condition config.")
				return False
			elif not is_match(target, each):
				match_flag = False
		return match_flag

	def _search_mydb(self, info, customer_name=None, rec_type="malware"):
		if customer_name is None:
			customer_name = self.alert["alert_src"]["customer_name"]
		for i in range(0, 3):
			try:
				return self.intel.search(info, self.product, customer_name, rec_type, max_count=1000)
			except OSError as e:
				self.logger.warning("error occurred at search_mydb({})".format(e.message))
			except IOError as e:
				self.logger.warning("error occurred at search_mydb({})".format(e.message))
		return []

	def _get_malware_info(self, sha256Hash):
		for each in self.alert["alert_detail"]["malware_info"]:
			if each["ps_hash"] == sha256Hash:
				return each
		return None

	def _search_splunk_wDHSOC(self, customer_name, sha256):
		if customer_name:
			customer_name = customer_name.lower()
		if self.get_all_hashes:
			result = []
			if customer_name in self.chached_hashes:
				if sha256 in self.chached_hashes[customer_name]:
					result.append(self.chached_hashes[customer_name][sha256])
			if len(result) is 0:
				if sha256 in self.chached_hashes["all"]:
					result.append(self.chached_hashes["all"][sha256])
		else:
			queries = self._get_query4dhsoc(customer_name, sha256)
			result = self.splunk.raw_search(queries)
		return result

	def _get_all_wDHSOC(self):
		queries = self._get_query4dhsoc()
		result = self.splunk.raw_search(queries, max_count=0)
		return result

	def _cache_appinfo_wDHSOC(self):
		raw_results = [ dict(each) for each in self._get_all_wDHSOC() ]
		results = { "all" : {} }
		for each in raw_results:
			if not "customer_name" in each or not "hash" in each:
				continue
			customer_name = each["customer_name"].lower()
			if not customer_name in results:
				results[customer_name] = {}
			results[customer_name][each["hash"]] = each
		self.chached_hashes = results
		self.get_all_hashes = True

	def _search_splunk_wCyfirma(self, sha256):
		#queries = self._get_query4cyfirma(sha256)
		#result = self.splunk.raw_search(queries)
		result = self.cyfirma.check_hashes( [ sha256 ] )
		if len(result) > 1:
			return [ result[0] ]
		else:
			return result

