# -*- coding: utf-8 -*-

import os, sys
import json, re, glob
from ipaddress import ip_address, IPv6Address
from logging import getLogger
from priv_module_helpers.splunk_helpers import splunk_searcher as _splunk

from validator_base import ValidatorBase
from . import TYPECODE_MALWARE, BLACK, WHITE, GRAY

dirpath = os.path.dirname( os.path.abspath(__file__) )+"/"
apppath = dirpath+"../../"

_IOC_SPLUNK = "splunk-license01.dhsoc.jp"

def get_logger(log_name="MalwareValidator"):
	return getLogger(log_name)

class MalwareValidator(ValidatorBase):
	search_index = "dhsoc_hash_info"
	search_source = "analyst_feedback"
	search_earliest = "-10y@y"
	search_latest   = "now"

	cyfirma_index = "cyfirma_ioc"
	cyfirma_source = "cyfirma"
	cached_hashes = { "all" : {} }
	get_all_hashes = False
	splunk = _splunk.MySearcher

	@classmethod
	def initialize_module(cls, is_fource=False):
		#logger = get_logger()
		#logger.info("initialize malware validator")
		if cls.get_all_hashes:
			if not is_fource:
				return
		cls._init_splunk()
		cls._cache_appinfo_wDHSOC()
		cls.get_all_hashes = True

	@classmethod
	def is_target(cls, alert):
		details = alert["alert_detail"].get("malware_detail")
		if details:
			return len(details) > 0
		else:
			return False

	def __init__(self, alert, validator_config, intel, cyfirma, product, customer, vtapi, rm_helper=None):
		super(MalwareValidator, self).__init__(alert, 
				TYPECODE_MALWARE, get_logger(),
				product=product,  customer=customer,
				cyfirma=cyfirma,  validator_config=validator_config,
				intel=intel,      vtapi=vtapi,
				rm_helper=rm_helper)
		self.results["malware"] = {}
		self._init_splunk()
		if not self.get_all_hashes:
			self._cache_appinfo_wDHSOC()

	@classmethod
	def _init_splunk(cls):
		if not cls.splunk.is_init():
			if "." in _IOC_SPLUNK:
				cfg_name = _IOC_SPLUNK.split(".")[0]
			else:
				cfg_name = _IOC_SPLUNK
			cls.splunk.init_splunk_by_cfg_file(cfg_name, app="dhsoc_ioc")

	def validate_falsepositive(self):
		self.logger.info( "start to FP check at malware alert." )
		msg = ""
		customer_name = self.alert["alert_src"]["customer_name"]
		results = []
		hashes = list(set([ each["file_hash"]
			for each in self.alert["alert_detail"]["malware_detail"] ]))
		for each in hashes:
			if not each:
				severity = "-"
				ticket_id = "N/A"
				msg = "ハッシュ情報なし。確認不可。本件については過検知と判定。"
				self.logger.debug("{} : {} : {}".format(severity, ticket_id, msg))
				results.append({"severity"  : severity,
								"message"   : msg,
								"hash"      : each,
								"ticket_id" : ticket_id })
				continue
			severity, ticket_id, msg = self.check_each_malware(customer_name, each)
			#if severity in [ "中", "高", None ]:
			if severity is None:
				if self._check_fp_by_malware_type(each):
					severity = u"未"
			if severity == "cyfirma":
				severity = None
			self.logger.debug("{} : {} : {}".format(severity, ticket_id, msg))
			results.append({"severity"  : severity,
							"message"   : msg,
							"hash"      : each,
							"ticket_id" : ticket_id })
		severity = self._get_high_severity(results)
		if severity is None:
			self.is_positive = True
			self.is_emerg = True
		else:
			self.correct_severity = severity
			if severity == "-":
				self.is_positive = False
			elif severity == "未":
				self.is_positive = True
				self.is_gray = True
			else:
				self.is_positive = True
				self.is_emerg = True
		self.results["malware"]["result"] = results
		self.logger.info("highest severity:{} at ID:{}".format(
			severity, self.alert["alert_summary"]["alert_id"] ))

	def _check_severity_by_malware_type(self, sha256Hash):
		return False

	def _check_fp_by_malware_type(self, sha256Hash): #TODO
		return False

	def _get_high_severity(self, results):
		def get_score(curr_severity):
			if curr_severity == "-":
				return 1
			elif curr_severity == "低":
				return 2
			elif curr_severity == "未":
				return 3
			elif curr_severity is None:
				return 4
			elif curr_severity == "中":
				return 5
			elif curr_severity == "高":
				return 6
			else:
				return 0

		severity = None
		score = 0
		self.logger.debug("alert num is {}".format(len(results)))
		for each in results:
			curr_severity = each["severity"]
			curr_score = get_score(curr_severity)
			self.logger.debug("Severity:{} Score:{}".format(
				curr_severity, curr_score))
			if score < curr_score:
				score = curr_score
				severity = curr_severity
		return severity

	def check_each_malware(self, customer_name, sha256):
		self.logger.debug("check by DHSOC Hash IOC.")
		res = self._search_splunk_wDHSOC(customer_name, sha256)
		if len(res) is not 0:
			info = res[0]
			self.logger.info("{} is detected by DHSOC IOC(Hash).".format(sha256))
			if "analyst_comment" in info:
				return info["severity"], info["ticket_id"], info["analyst_comment"]
			else:
				return info["severity"], info["ticket_id"], ""

		self.logger.debug("check by DHSOC Condition Based IOC.")
		res = self._search_splunk_wCyfirma(sha256)
		if len(res) is not 0:
			res = res[0]
			self.logger.debug("detected by cyfirma:{}".format(res.get("id")))
			msg = "detected by cyfirma IOC. fileName:{}".format(
					res.get("file_name"))
			return "cyfirma", "cyfirmaID:{}".format(res.get("id")), msg

		self.logger.debug("unknown by cyfirma IOC.")
		try:
			ticket_id, severity, msg = self._getinfo_by_malware_hash_at_past_ticket_in_redmine(sha256)
			if ticket_id:
				if severity == "-" or severity == "低":
					severity = "未" #TODO アナリストチェック可能な状態にするため(一時的な措置)
				return severity, ticket_id, msg
		except Exception as e:
			self.logger.info("error occurred at DHSOC RedMine Ticket Search.")
			self.logger.exception(e)
		self.logger.debug("unknown by redmine tickets in 7 days.")
		try:
			res = self._search_splunk_wDHSOC_Condition(customer_name, sha256)
			if len(res) is not 0:
				info = res[0]
				self.logger.info("{} is detected by DHSOC IOC(Condition).".format(sha256))
				rep = info["reputation"]
				if rep == "high":
					sev = u"高"
				elif rep == "medium":
					sev = u"中"
				elif rep == "low":
					sev = u"低"
				elif rep == "gray":
					sev = u"未"
				elif rep == "white":
					sev = u"-"
				else:
					sev = None
				return sev, info["id"], info["message"]
		except Exception as e:
			self.logger.info("error occurred at DHSOC Condition based IOC.")
			self.logger.exception(e)
		self.logger.debug("unknown by dhsoc IOC.")
		if self._check_severity_by_malware_type(sha256):
			severity = u"低"
			msg = "this is low risk(PUP/Adware etc) malware."
			return severity, None, msg
		elif self._is_pup(sha256):
			self.logger.debug("this hash is PUP.")
			severity = "低"
			msg =  "unknown PUP without virustotal."
			return severity, None, msg
		else:
			exist, severity, msg = self._check_by_virustotal(sha256)
			if exist:
				return severity, None, "virustotal check:({})".format(msg)
			else:
				self.logger.debug("unknown by virustotal.")
				return severity, None, "unknown all"

	def _getinfo_by_malware_hash_at_past_ticket_in_redmine(self, ps_hash):
		info = self.rm_helper.get_info_by_hash_from_past_ticket(
				ps_hash, customer=self.alert["alert_src"]["customer_name"])
		if info:
			return info["ticket_id"], info["severity"], info["message"]
		else:
			return None, None, None

	def _check_by_virustotal(self, ps_hash):
		def detect_detail_to_str(detected_detail):
			msg = []
			for each in detected_detail:
				msg.append(
						"{}:{}".format(each["vendor"], each["result"])
				)
			return "\n".join(msg)

		result = self.vtapi.search_hashes( [ps_hash] )
		res = result[0]
		if not res["exist"]:
			return None, None, None
		vendor_num = len(res["detected_vendors"])
		msg = detect_detail_to_str(res["detected_detail"])
		msg = "VirusTotal({})\n{}".format(res["result"], msg)
		rep = self.vtapi.check_reputation("hash", res)
		self.logger.debug("VirusTotal check result:{}".format(rep["reputation"]))
		if rep["reputation"] in ("benign", "suspicious"):
			return True, u"未", msg 
		else:
			return True, None, msg 

# private
	def _get_query4cyfirma(self, file_hash):
		q  = 'search index="{}" source="{}" earliest="{}" latest="{}" {}'.format(
				self.cyfirma_index,    self.cyfirma_source,
				self.search_earliest, self.search_latest,
				file_hash )
		q += '| rename observable.object.properties.fileName.value as file_name'
		q += '| table _time,id,file_name,_raw'
		q += '| dedup file_name sortby -_time'
		q += '| head 1'
		return q

	@classmethod
	def _get_query4dhsoc(cls, customer_name=None, file_hash=None):
		q  = 'search index="{}" source="{}" earliest="{}" latest="{}" '.format(
				cls.search_index,    cls.search_source,
				cls.search_earliest, cls.search_latest )
		cond = ""
		if file_hash:
			cond = ' hash="{}" '.format(file_hash)
		if customer_name:
			if not cond == "":
				cond += " AND "
			q += ' ( customer_name="all" OR customer_name="{}" ) '.format(
					customer_name)
		q += cond
		q += '| spath customer_name | spath hash | spath analyst{}.note'
		q += '| where isnotnull(customer_name) AND  isnotnull(hash) '
		q += '| rename analyst{}.note as analyst_comment'
		q += '| table _time,customer_name,analyst_comment,hash,ticket_id,severity'
		q += '| dedup hash sortby -_time'
		return q

	def _search_splunk_wDHSOC_Condition(self, customer_name, sha256):
		malinfo = self._get_malware_info(sha256)
		result = []
		if malinfo:
			is_match = False
			records = self._search_mydb("malware", "malware")
			self.logger.debug("checked condition Num:{}".format(len(records)))
			ps_name = malinfo.get("process_name")
			ps_pid  = malinfo.get("process_id")

			for rec in records:
				rec_id     = rec.get("id")
				rec_rev    = rec.get("rev")
				reputation = rec.get("reputation")
				message    = rec.get("message")
				detail     = rec.get("detail")
				try:
					is_match = self.fp_check_malware_by_each_record(
						ps_name, ps_pid,  sha256,     rec,
						rec_id,  rec_rev, reputation, message, detail)
					if is_match:
						self.logger.info("alert is matched ID:[{}] Rev:[{}]".format(
							rec.get("id"), rec.get("rev")))
						break
				except Exception as e:
					self.logger.error("unknown error at checking record ID:{}".format(rec_id))
					self.logger.exception(e)
			if is_match:
				self.logger.debug("DHSOC Condition based IOC -> ID:{} is Matched.".format(rec_id, reputation))
			else:
				self.logger.debug("un-match any conditions.")
				reputation = None
				message = "unmatched any conditions"
				rec_id = None

			if reputation and rec_id:
				each_res = { "id"    : rec_id,
						"reputation" : reputation,
						"hash"       : sha256,
						"message"    : message }
				result.append(each_res)
		return result

	def fp_check_malware_by_each_record(self, ps_name, ps_pid, sha256,
				rec, rec_id, rec_rev, reputation, message, detail):
		is_match = None
		if not( isinstance(rec_id,  basestring) and
				isinstance(rec_rev, basestring) ):
			self.logger.warning(
					"this record is corrupt. ID:{}".format(rec_id))
			return None
		elif not reputation in ("black", "white", "gray", "high", "low", "medium"):
			self.logger.warning(
					"has no correct reputation info [{}]".format(rec))
			return None
		elif not(isinstance(detail, dict) and detail.get("expected")):
			self.logger.warning("record is corrupted. [{}]".format(rec))
			return None
		allconditions = detail["expected"]
		if not(isinstance(allconditions, list)):
			self.logger.warning("record is corrupted. [{}]".format(rec))
			return None
		is_match = True
		for cnd_group in allconditions:
			target, conditions = self._get_match_target(
					cnd_group, ps_name, ps_pid)
			if not(target and conditions):
				self.logger.info(
						"data or conditions are null(or blank).")
				is_match = False
			elif not self._is_match_allcondition(target, conditions):
				self.logger.debug(
						"unmatch condition.")
				is_match = False
		return is_match

	def _get_match_target(self, cnd_group, ps_name, ps_pid):
		if isinstance(cnd_group, dict):
			position = cnd_group.get("data_position")
			conditions = cnd_group.get("conditions")
			if isinstance(position, basestring):
				if position == "event_detail":
					self.logger.debug("data position is event_detail")
					data = self.alert["alert_detail"]["event_detail"]
					data = [] if data is None else data
					for each in data:
						if ps_pid == each.get("process_id"):
							return each, conditions
				elif position == "process_detail":
					self.logger.debug("data position is process_detail")
					data = self.alert["alert_detail"]["process_detail"]
					data = [] if data is None else data
					for each in data:
						if ps_pid == each.get("process_id"):
							return each, conditions
				elif position == "malware_detail":
					self.logger.debug("data position is malware_detail")
					data = self.alert["alert_detail"]["malware_detail"]
					data = [] if data is None else data
					for each in data:
						if ps_pid == each.get("process_id"):
							return each, conditions
		return None, None

	def _is_match_allcondition(self, target, conditions):
		def is_match(data, cond):
			field = cond["field"]
			value = cond["value"]
			dtype = cond["type"]
			op    = cond["op"]
			section = cond["section"]
			if isinstance(section, basestring):
				data = data.get(section)
			if data and field in data:
				target_value = str(data[field])
				if dtype == "regex" or dtype == "regexp":
					result = re.search(value, target_value) is not None
					if result is False:
						try:
							value2 = value.encode("utf-8")
							result = re.search(value2, target_value) is not None
						except Exception as e:
							pass
				elif dtype == "ciexact":
					result = (value.lower() == target_value.lower())
				elif dtype == "exact":
					result = (value == target_value)
				elif dtype == "exact":
					result = (value == target_value)
				elif dtype == "include":
					result = (value in target_value)
				elif dtype == "ciinclude":
					result = (value.lower() in target_value.lower())
				elif dtype.startswith("length"):
					if dtype.endswith("gt"):
						result = (value > len(target_value))
					elif dtype.endswith("lt"):
						result = (value < len(target_value))
					else:
						result = (value == len(target_value))
				else:
					result = None
				if result is None:
					return False
				elif op == "not":
					return not result
				else:
					return result
			return False
		def is_except_condition(each):
			return( "section" in each and
					each.get("op") in (None, "not") and
					isinstance(each.get("field"), basestring) and
					isinstance(each.get("type"),  basestring) and
					isinstance(each.get("value"), basestring) )

		if not(isinstance(conditions, list) and len(conditions) > 0):
			return False
		match_flag = True
		for each in conditions:
			if not is_except_condition(each):
				self.logger.info("this is corrupt condition config.")
				return False
			elif not is_match(target, each):
				match_flag = False
		return match_flag

	def _get_malware_info(self, sha256Hash):
		for each in self.alert["alert_detail"]["malware_detail"]:
			if each["file_hash"] == sha256Hash:
				return each
		return None

	def _search_splunk_wDHSOC(self, customer_name, sha256):
		if customer_name:
			customer_name = customer_name.lower()
		if self.get_all_hashes:
			result = []
			if customer_name in self.cached_hashes:
				if sha256 in self.cached_hashes[customer_name]:
					result.append(self.cached_hashes[customer_name][sha256])
			if len(result) is 0:
				if sha256 in self.cached_hashes["all"]:
					result.append(self.cached_hashes["all"][sha256])
		else:
			queries = self._get_query4dhsoc(customer_name, sha256)
			result = self.splunk.raw_search(queries)
		return result

	@classmethod
	def _get_all_wDHSOC(cls):
		logger = get_logger()
		queries = cls._get_query4dhsoc()
		result = cls.splunk.raw_search(queries, max_count=0)
		logger.info("Total dhsoc_hash_info Num:{}".format(len(result)))
		return result

	@classmethod
	def _cache_appinfo_wDHSOC(cls):
		logger = get_logger()
		logger.info("cached dhsoc_hash_info.")
		raw_results = [ dict(each) for each in cls._get_all_wDHSOC() ]
		results = { "all" : {} }
		for each in raw_results:
			if not "customer_name" in each or not "hash" in each:
				continue
			customer_name = each["customer_name"].lower()
			if not customer_name in results:
				results[customer_name] = {}
			results[customer_name][each["hash"]] = each
		MalwareValidator.cached_hashes = results
		MalwareValidator.get_all_hashes = True

	def _search_splunk_wCyfirma(self, sha256):
		result = self.cyfirma.check_hashes( [ sha256 ] )
		#queries = self._get_query4cyfirma(sha256)
		#result = self.splunk.raw_search(queries)
		if len(result) > 1:
			return [ result[0] ]
		else:
			return result

	def _is_pup(self, sha256Hash):
		return False

